<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa"
        crossorigin="anonymous"></script>

    <!-- fontawesome -->
    <script src="https://kit.fontawesome.com/490ac8585b.js" crossorigin="anonymous"></script>


    <script>
        var stepToCSS = 'px'
        var stepToCalc = 50
        var step = 5

        var leftPos = 0
        var topPos = 0
        var timeDelay = 150

        var isMoving
        var lastInput

        var actualDirection = null

        var ms = timeDelay / 10
        var temp = null
        var timeInputs
        var timeBetweenInputs = 0
        var firstKey = false
        var counter = 0
        var numberKeysDown = 0

        var lastPosTop = 0
        var lastPosLeft = 0

        var score = 0

        var isExecutingW = false
        var isExecutingS = false
        var isExecutingA = false
        var isExecutingD = false
        var isExecutingContinuos = false

        var singleInput = false

        var arrayKeys = new Array()
        var arrayBody = new Array()

        var moveKeys = /[wsad]/i
        document.onkeydown = function (asd) {
            if (asd.key.match(moveKeys) && asd.key.length === 1) {
                moveSnake(asd.key)
                firstKey = true

                counter = 0
                if (numberKeysDown % 2 === 0) { //Contador para evitar dupla inserção de teclas
                    if (timeInputs === undefined) {
                        timeInputs = setInterval(
                            function () {
                                counter++
                                //document.getElementById('h1-nav').innerHTML = counter
                            }, 1
                        )
                    }
                }
                numberKeysDown++
            }
            else if (asd.key == 'p') {
                if (isMoving != undefined) {
                    window.cancelAnimationFrame(isMoving)
                    isMoving = undefined
                }
                else {
                    moveSnake(asd.key)
                }
            }
            else if (asd.key == 'm') {
                singleInput = singleInput === false ? true : false
            }

        }

        var posString = ''
        var operationString = ''
        var isLeft = false
        var isValid = false

        function notExecuting() {
            isExecutingW = false
            isExecutingS = false
            isExecutingA = false
            isExecutingD = false
        }
        function isExecuting() {
            if (isExecutingW === true || isExecutingS === true || isExecutingA === true || isExecutingD === true || isExecutingContinuos === true) {
                return true
            }
            else {
                return false
            }
        }


        var lastPosBodyLeft
        var lastPosBodyTop
        var arrayLastPositions = new Array()
        var lengthBody = 10
        var isEating = false

        var lastPosTopSnake
        var lastPosLeftSnake
        var endCycle = 0
        var statusDirection = { x: 'none', y: 'none', lastX: 'none', lastY: 'none' }

        function canMove(firstTarget, secondTarget, operation) {

            arrayLastPositions.push({ left: leftPos, top: topPos })

            lengthBody = score === 0 ? lengthBody : 10 * (score + 1)

            let indexLocal = lengthBody - 11 < 0 ? 0 : lengthBody - 11


            if (arrayLastPositions.length === lengthBody || isEating === true) { //Continuos

                if (indexLocal != 0 && arrayLastPositions.length === lengthBody) { arrayLastPositions.shift(); isEating = false }
                lastPosLeft = arrayLastPositions[indexLocal].left
                lastPosTop = arrayLastPositions[indexLocal].top
                if (indexLocal === 0 && arrayLastPositions.length === lengthBody) { arrayLastPositions.shift() }
            }
            //console.log(arrayLastPositions)

            if (bodySet.length === 0) {
                lastPosBodyLeft = lastPosLeft
                lastPosBodyTop = lastPosTop
            }

            if (operation == '+') {
                if (firstTarget == 'leftPos') {
                    leftPos += step
                }
                else {
                    topPos += step
                }
            }
            else {
                if (firstTarget == 'leftPos') {
                    leftPos -= step
                }
                else {
                    topPos -= step
                }
            }

            lastPosLeftSnake = lastPosLeftSnake === undefined ? leftPos : lastPosLeftSnake
            lastPosTopSnake = lastPosTopSnake === undefined ? topPos : lastPosTopSnake

            colissionBody()

            if (leaveMap()) {
                clearAllInterval()
                window.cancelAnimationFrame(isMoving)
            }
            else if (isCollidingBody === false) {

                if (hasBody) {
                    filletBodyApply()

                }
                else {
                    lastPosLeftSnake = leftPos
                    lastPosTopSnake = topPos
                }

                snakePos = document.getElementById('snake').style

                if (secondTarget === true) {
                    snakePos.left = leftPos + stepToCSS
                }
                else {
                    snakePos.top = topPos + stepToCSS
                }

                if (isHeadAnimation) {
                    drawHead(lastAnimationHead.angle, lastAnimationHead.type)
                }

                if (isBodyAnimation) {
                    drawLast(lastAnimationBody.angle, lastAnimationBody.type, lastAnimationBody.pivot)
                }
                else {
                    lastBodyDirection()
                }

                if (leftPos % 50 === 0 && topPos % 50 === 0) {
                    //Adiciona posição à lista de banimento de posicionamento para a comida, pois está em uso
                    indexThereSomething.push(coordToIndex(Math.round(leftPos / 50) * 50, Math.round(topPos / 50) * 50))
                    //console.log(indexThereSomething)
                }
            }
        }


        function defaultMove() {

            if (leftPos % 50 === 0 && topPos % 50 === 0) {
                if (arrayKeys.length != 0) {
                    whichDirection(arrayKeys[0])
                    arrayKeys.shift()
                }


                if (arrayLastKeys.length != 0) {
                    whichDirection(arrayLastKeys[0])
                    arrayLastKeys.shift()
                }
            }

            notExecuting()

            canMove(posString, isLeft, operationString)


            if (leaveMap() === false && isCollidingBody === false) {

                bodySnakeApply()

                collisionFood()

                snakeConectionFunc()

                if (hasBody === false && indexThereSomething.length > 1) {
                    //console.log('INDEX RETIRADO SE NÃO HAVER CORPO: ' + indexThereSomething[0])
                    indexThereSomething.shift()
                    //console.log(indexThereSomething)
                }
                if (singleInput === false) { isMoving = window.requestAnimationFrame(defaultMove) }
                else if (repeat < stepToCalc - 5) {
                    window.requestAnimationFrame(defaultMove)
                    //console.log('BBBBB: ' + repeat)
                    repeat += step
                }
            }

        }

        var repeat = 0
        var arrayLastKeys = new Array()

        function moveSnake(directionLocal) {

            if (leftPos % 50 === 0 && topPos % 50 === 0) {
                if (arrayLastKeys.length === 0) {
                    whichDirection(directionLocal)
                }
            }
            else {
                arrayLastKeys.push(directionLocal)
            }

            if (singleInput === true) {
                repeat = 0
                defaultMove()
            }
            else {
                if (isMoving === undefined) {
                    if (isValid === true) {
                        isMoving = window.requestAnimationFrame(defaultMove)
                    }
                }
            }
        }

        function whichDirection(direction) {
            //console.log('DIRECTION: ' + direction)
            //console.log('arrayKEYS: ' + arrayKeys)
            switch (direction) {

                case 'w':
                    if (actualDirection != 's' && isExecuting() === false) {
                        isExecutingW = true
                        posString = 'topPos'
                        operationString = '-'
                        isLeft = false
                        actualDirection = 'w'
                        //console.log('W')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('W')
                        arrayKeys.push(direction)
                    }
                    break

                case 's':
                    if (actualDirection != 'w' && isExecuting() === false) {
                        isExecutingS = true
                        posString = 'topPos'
                        operationString = '+'
                        isLeft = false
                        actualDirection = 's'
                        //console.log('S')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('S')
                        arrayKeys.push(direction)
                    }
                    break

                case 'a':
                    if (actualDirection != 'd' && isExecuting() === false) {
                        isExecutingA = true
                        posString = 'leftPos'
                        operationString = '-'
                        isLeft = true
                        actualDirection = 'a'
                        //console.log('A')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('A')
                        arrayKeys.push(direction)
                    }
                    break

                case 'd':
                    if (actualDirection != 'a' && isExecuting() === false) {
                        isExecutingD = true
                        posString = 'leftPos'
                        operationString = '+'
                        isLeft = true
                        actualDirection = 'd'
                        //console.log('D')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('D')
                        arrayKeys.push(direction)
                    }
                    break
            }
        }
        function clearAllInterval() {
            clearInterval(temp)
            clearInterval(timeInputs)
        }
        function leaveMap() {
            if (leftPos < 0 || leftPos > 1400 - stepToCalc || topPos < 0 || topPos > 600 - stepToCalc) {
                return true
            }
            else {
                return false
            }
        }

        var isCollidingBody = false

        function colissionBody() {

            if (hasBody === true) {

                bodySnakeComputed()

                if (bodySet.length > 2) {
                    for (let i = 0; i < bodySet.length; i++) {


                        if (i != bodySet.length - 1) {
                            if (positiveNumber(bodyArray[i].left - roundByDirection(leftPos)) < 50 &&
                                positiveNumber(bodyArray[i].top - roundByDirection(topPos)) < 50) {
                                isCollidingBody = true
                                break
                            }
                        }
                        else {
                            if (positiveNumber(bodyArray[i - 1].left - roundByDirection(leftPos)) < 50 &&
                                positiveNumber(bodyArray[i - 1].top - roundByDirection(topPos)) < 50) {
                                isCollidingBody = true
                                break
                            }
                        }
                    }
                }
            }
        }
        function collisionFood() { //Melhorar sistema de colisão com a comida, há falhas não frequentes

            redeclareConst()

            if (snakePosGet.top === foodPosGet.top && snakePosGet.left === foodPosGet.left) {

                randomPosition()

                hasBody = true

                document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + lastPosBodyLeft + stepToCSS + '; top: ' + lastPosBodyTop + stepToCSS + '"><span class="snake-body-style"></span></span>'

                isEating = true
                score++
                document.getElementById('h1-nav').innerHTML = score


                redeclareConst()
                drawAll()
                drawHead(lastAnimationHead.angle, lastAnimationHead.type)
                drawLast(lastAnimationBody.angle, lastAnimationBody.type, lastAnimationBody.pivot)
            }

        }
        function redeclareConst() {
            snakePos = document.getElementById('snake').style

            lastBody = document.getElementById('last-body')
            snakeHead = document.getElementById('snake-head')
            canvasHead = document.getElementById('canvas-head')

            snakeConection = document.getElementById('snake-conection').style
            foodPos = document.getElementById('food').style
            snakePosGet = window.getComputedStyle(document.getElementById('snake'))
            foodPosGet = window.getComputedStyle(document.getElementById('food'))
        }

        var mapWidth
        var mapHeight
        var allPos = []
        var allIndex = []
        function initiate() {

            mapWidth = 700 - stepToCalc
            mapHeight = 600 - stepToCalc

            let i = 0

            for (let x = 0; x <= mapWidth; x += stepToCalc) {
                for (let y = 0; y <= mapHeight; y += stepToCalc) {
                    allPos.push({ left: x, top: y })
                    allIndex.push(i)
                    i++
                }
            }
            //temporário spawn
            leftPos = 200
            topPos = 200
            snakePos.left = '200px'
            snakePos.top = '200px'
            for (let x = 0; x < 29; x++) {
                arrayLastPositions[x] = { left: 55 + x * 5, top: 200 }
            }
            //lengthBody = score === 0 ? lengthBody : 10 * (score + 1)
            score = 2
            //console.log(arrayLastPositions  )
            hasBody = true
            statusDirection.x = 'right'
            statusDirection.y = 'bottom'
            statusDirection.lastX = 0
            statusDirection.lastY = 200
            lastPosLeftSnake = 200
            lastPosTopSnake = 200
            document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + 150 + stepToCSS + '; top: ' + 200 + stepToCSS + '"><span class="snake-body-style" style="width: 60px; height: 40px"></span></span>'
            document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + 100 + stepToCSS + '; top: ' + 200 + stepToCSS + '"><span class="snake-body-style" style="width: 60px; height: 40px"></span></span>'
            redeclareConst()
            lastBody.style.left = '100px'
            lastBody.style.top = '200px'


            lastBodyStatus.x = 'right'
            lastBodyStatus.y = 'bottom'
            lastBodyStatus.lastX = 50
            lastBodyStatus.lastY = 200

            drawHead()
            onlyDrawLast()
            //console.log(allPos)
        }

        function checkThereSomething(value) {

            let there = false

            for (let i = 0; i < indexThereSomething.length; i++) {
                if (indexThereSomething[i] === value) {
                    there = true
                    break
                }
            }
            if (there === false) { return value }
        }

        function randomNumber() {

            let tempAllIndex = allIndex.filter(checkThereSomething)

            let value = tempAllIndex[Math.floor(Math.random() * tempAllIndex.length)]
            //console.log(tempAllIndex)
            //console.log(value)
            return value
        }

        var indexThereSomething = []

        function randomPosition() {


            let index = randomNumber()
            foodPos.left = allPos[index].left + stepToCSS
            foodPos.top = allPos[index].top + stepToCSS

        }

        function coordToIndex(left, top) {

            let x1 = left / 50 * 12
            let y1 = top / 50
            let temp

            if (y1 == 0) {
                temp = x1
            }
            else {
                temp = Number(x1 + y1)
            }

            return temp
        }

        var bodyArray = new Array()
        const bodySet = document.getElementsByClassName('snake-body')
        const bodySetStyle = document.getElementsByClassName('snake-body-style')

        var hasBody = false
        var indexToCalculateFillet = 0
        var auxIndexLast = 0
        var auxIndexOthers = 0

        function bodySnakeComputed() {

            for (let i = 0; i < bodySet.length; i++) {
                if (i != bodySet.length - 1) {
                    if (isEating) {
                        bodyArray[i] = arrayLastPositions[lengthBody - (10 * i) - 20 + auxIndexOthers]
                    }
                    else {
                        bodyArray[i] = arrayLastPositions[lengthBody - (10 * i) - 11]
                    }

                }
                else {
                    if (isEating) {
                        auxIndexOthers++
                        bodyArray[i] = arrayLastPositions[auxIndexLast]
                        if (auxIndexLast === 9) {
                            isEating = false
                            auxIndexLast = 0
                            auxIndexOthers = 0
                        }
                        else {
                            auxIndexLast++
                        }
                    }
                    else {
                        bodyArray[i] = arrayLastPositions[9]
                    }

                    lastPosBodyLeft = arrayLastPositions[0].left
                    lastPosBodyTop = arrayLastPositions[0].top


                    try {
                        if (leftPos % 50 === 0 && topPos % 50 === 0) {

                            if (bodyArray[i].left === allPos[indexThereSomething[1]].left &&
                                bodyArray[i].top === allPos[indexThereSomething[1]].top) {

                                indexThereSomething.shift()

                            }
                        }
                    } catch { }
                }


                if (i === 1) {
                    indexToCalculateFillet = lengthBody - (10 * i) - 11
                }
            }
        }

        function clearUn(value) {
            return Number(value.replace('px', ''))
        }

        function roundValue(value) {
            return Math.round(value / 50) * 50
        }

        function positiveNumber(value) {
            if (value < 0) {
                return value * -1
            }
            else {
                return value
            }
        }

        function roundByDirection(value) {

            let a

            switch (actualDirection) {
                case 'w':
                    a = Math.floor(value / 50) * 50
                    break
                case 's':
                    a = Math.ceil(value / 50) * 50
                    break
                case 'a':
                    a = Math.floor(value / 50) * 50
                    break
                case 'd':
                    a = Math.ceil(value / 50) * 50
                    break
            }
            return a
        }

        function absoluteValue(a, b) {
            a = positiveNumber(a)
            b = positiveNumber(b)
            return positiveNumber(a - b)
        }

        var statusDirection = { x: 'none', y: 'none', lastX: 'none', lastY: 'none' }
        function filletBodyApply() {
            if (lastPosLeftSnake != leftPos && endCycle === 0) {
                endCycle++
                if (statusDirection.lastY != topPos) {
                    if (lastPosLeftSnake > leftPos) {
                        //console.log('INDO PARA ESQUERDA')
                        if (statusDirection.y === 'top') {
                            drawHead(-180, '-')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 0, 5, -5, bodyArray.length)
                            //snakeHead.backgroundColor = 'red'
                            statusDirection.lastY = topPos
                        }
                        else if (statusDirection.y === 'bottom') {
                            drawHead(180, '+')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 90, 5, 5, bodyArray.length)
                            //snakeHead.backgroundColor = 'blue'
                            statusDirection.lastY = topPos
                        }
                        statusDirection.x = 'left'
                    }
                    else if (lastPosLeftSnake < leftPos) {
                        //console.log("INDO PARA DIREITA")
                        if (statusDirection.y === 'top') {
                            drawHead(0, '+')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 270, -5, -5, bodyArray.length)
                            //snakeHead.backgroundColor = 'orange'
                            statusDirection.lastY = topPos
                        }
                        else if (statusDirection.y === 'bottom') {
                            drawHead(0, '-')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 180, -5, 5, bodyArray.length)
                            //snakeHead.backgroundColor = 'white'
                            statusDirection.lastY = topPos
                        }
                        statusDirection.x = 'right'
                    }
                }

                lastPosLeftSnake = leftPos
            }
            else if (lastPosTopSnake != topPos && endCycle === 0 && bodySet.length > 0) {
                endCycle++
                //console.log('TOP DIFERENTE')

                if (statusDirection.lastX != leftPos) {
                    if (lastPosTopSnake > topPos) {
                        //console.log('INDO PARA CIMA')
                        if (statusDirection.x === 'left') {
                            drawHead(270, '+')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 180, -5, 5, bodyArray.length)
                            //snakeHead.backgroundColor = 'lightblue'
                            statusDirection.lastX = leftPos
                        }
                        else if (statusDirection.x === 'right') {
                            drawHead(-90, '-')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 90, 5, 5, bodyArray.length)
                            //snakeHead.backgroundColor = 'darkred'
                            statusDirection.lastX = leftPos
                        }
                        statusDirection.y = 'top'
                    }
                    else if (lastPosTopSnake < topPos) {
                        //console.log('INDO PARA BAIXO')
                        if (statusDirection.x === 'left') {
                            drawHead(-270, '-')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 270, -5, -5, bodyArray.length)
                            //snakeHead.backgroundColor = 'darkgreen'
                            statusDirection.lastX = leftPos
                        }
                        else if (statusDirection.x === 'right') {
                            drawHead(90, '+')
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 0, 5, -5, bodyArray.length)
                            //snakeHead.backgroundColor = 'purple'
                            statusDirection.lastX = leftPos
                        }
                        statusDirection.y = 'bottom'
                    }
                }
                lastPosTopSnake = topPos
            }

            if (endCycle != 0) {
                if (leftPos % 50 === 0 && topPos % 50 === 0) {
                    endCycle = 0
                    lastPosLeftSnake = leftPos
                    lastPosTopSnake = topPos
                }
                //console.log(statusDirection)
            }
        }

        function bodySnakeApply() {

            let xy

            if (isCollidingBody === false) {

                for (let i = 0; i < bodySet.length; i++) {

                    xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[i])


                    if (bodyArray[i].left != clearUn(xy.left) && bodyArray[i].top == clearUn(xy.top)) {
                        bodySetStyle[i].style.width = '60px'
                        bodySetStyle[i].style.height = '40px'
                        bodySet[i].style.left = bodyArray[i].left + stepToCSS
                    }

                    if (bodyArray[i].top != clearUn(xy.top) && bodyArray[i].left == clearUn(xy.left)) {
                        bodySetStyle[i].style.width = '40px'
                        bodySetStyle[i].style.height = '60px'
                        bodySet[i].style.top = bodyArray[i].top + stepToCSS
                    }


                    if (i === bodySet.length - 2) {

                        if (filletPosition.length != 0 && bodyArray[i].top === filletPosition[0].top && bodyArray[i].left === filletPosition[0].left) {

                            setTimeout(
                                function () {
                                    let fill = document.getElementsByClassName('fill')[0]
                                    if (leaveMap() === false && isCollidingBody === false) { fill.remove() }
                                }, 100
                            )

                            // let fill = document.getElementsByClassName('fill')[0]
                            // if (leaveMap() === false && isCollidingBody === false) { fill.remove() }

                            setTimeout(
                                function () {
                                    let fillet = document.getElementsByClassName('fillet')[0]
                                    if (leaveMap() === false && isCollidingBody === false) { fillet.remove() }
                                }, timeDelay + 100
                            )
                            filletPosition.shift()
                        }
                    }

                    if (i === bodySet.length - 1) {

                        if (true) {
                            lastBody.style.left = bodyArray[i].left + stepToCSS
                            lastBody.style.top = bodyArray[i].top + stepToCSS
                        }
                        bodySetStyle[i].style.display = 'none'
                        // if (leftPos % 50 === 0 && topPos % 50 === 0 || 1 > 0) {
                        //     bodySetStyle[i].style.display = 'none'
                        //     // if (bodyArray[bodySet.length - 2].left != bodyArray[bodySet.length - 1].left){
                        //     //     bodySetStyle[i].style.width = '40px'
                        //     //     bodySetStyle[i].style.height = '40px'
                        //     // }
                        //     // else if (bodyArray[bodySet.length - 2].top != bodyArray[bodySet.length - 1].top){
                        //     //     bodySetStyle[i].style.height = '40px'
                        //     //     bodySetStyle[i].style.width = '40px'
                        //     // }
                        // }
                    }
                    else{
                        bodySetStyle[i].style.display = 'block'
                    }
                }
            }
        }

        var filletPosition = []

        function drawFillet(posTop, posLeft, rotate, transX, transY, time) {

            document.getElementById('map').innerHTML += '<canvas class="fillet" width=50px height=50px></canvas>'
            document.getElementById('map').innerHTML += '<canvas class="fill" width=50px height=50px></canvas>'

            drawAll()

            let filletLocal = document.getElementsByClassName('fillet')[document.getElementsByClassName('fillet').length - 1]
            let fillLocal = document.getElementsByClassName('fill')[document.getElementsByClassName('fill').length - 1]


            filletPosition.push({ left: posLeft, top: posTop })


            filletLocal.style.left = (posLeft + transX) + stepToCSS
            filletLocal.style.top = (posTop + transY) + stepToCSS
            filletLocal.style.transform = 'rotate(' + rotate + 'deg)'

            fillLocal.style.left = (posLeft + transX) + stepToCSS
            fillLocal.style.top = (posTop + transY) + stepToCSS

            redeclareConst()
        }

        function drawAll() {
            //drawHead()
            onlyDrawLast()
            for (let x = 0; x < document.getElementsByClassName('fillet').length; x++) {

                let fillet = document.getElementsByClassName('fillet')[x]
                let ctx = fillet.getContext('2d')

                if (fillet.getContext) {
                    ctx.fillStyle = 'gray'
                    ctx.beginPath();
                    ctx.lineTo(50, 0)
                    ctx.lineTo(50, 50)
                    ctx.lineTo(40, 50)
                    ctx.arc(0, 50, 40, 0 * (Math.PI / 180), 270 * (Math.PI / 180), true)
                    ctx.lineTo(0, 0)
                    ctx.fill()
                }

                try {
                    let fill = document.getElementsByClassName('fill')[x]
                    let ctxFill = fill.getContext('2d')

                    if (fill.getContext) {
                        ctxFill.fillStyle = 'green'
                        ctxFill.fillRect(10, 10, 30, 30)
                    }
                } catch { }
            }

        }
        var angleHead = 0
        var lastAngleHead = 0
        var lastType
        var transXSnake = 0
        var transYSnake = 0
        var limitTranslate = 0
        var isOrigin = false

        var isHeadAnimation = false
        var lastAnimationHead = { angle: 0, type: 'none' }
        function drawHead(angle, type) {

            lastAnimationHead.angle = angle
            lastAnimationHead.type = type

            snakeHead = document.getElementById('snake-head')

            if (lastType != type && lastType != undefined && lastAngleHead != 0) {

                if (type === '-') {
                    angleHead -= 360
                    lastAngleHead -= 360
                }
                else {
                    angleHead += 360
                    lastAngleHead += 360
                }
            }

            lastType = lastType === type ? lastType : type
            type = type === '-' ? -1 : 1

            if (angle === 0 && positiveNumber(angleHead) >= 270) {
                angle = 360 * type
                isOrigin = true
            }

            if (angle != angleHead) {
                isHeadAnimation = true
                //console.log(angle)
                //console.log('POHA: ' + angle)
            }
            else {
                isHeadAnimation = false
                lastAngleHead = angle
                //canvasHead.style.transformOrigin = 'center center'
                if (isOrigin) {
                    angleHead = 0
                    lastAngleHead = 0
                    isOrigin = false
                }
            }

            if (angle != undefined && isHeadAnimation == true) {
                angleHead += ((absoluteValue(lastAngleHead, angle)) * type) / 10
            }

            snakeHead.style.transform = 'rotate(' + angleHead + 'deg)'// + 'translate(' +  lastAnimationHead.transY + 'px, ' + lastAnimationHead.transX  + 'px)'

            canvasHead = document.getElementById('canvas-head')
            let ctxHead = canvasHead.getContext('2d')

            if (canvasHead.getContext) {
                ctxHead.clearRect(0, 0, 60, 60)
                ctxHead.save()
                ctxHead.translate(5, 5)
                ctxHead.fillStyle = 'green'//'rgb(38, 8, 189)'
                ctxHead.beginPath()
                ctxHead.arc(-4.26, -79.87, 85, deg(90 - 2.87), deg(84.4262), true)
                ctxHead.arc(2.06, -15.18, 20, deg(90 - 5.5738), deg(61.8275), true)
                ctxHead.arc(17.17, 13.03, 12, deg(180 + 61.8275), deg(180 + 113.7578))
                ctxHead.arc(-18.29, 93.58, 100, deg(180 + 113.7578), deg(180 + 130.3635))
                ctxHead.arc(40, 25, 10, deg(180 + 130.3635), deg(0))
                ctxHead.arc(40, 25, 10, deg(0), deg(49.6365))
                ctxHead.arc(-18.29, -43.58, 100, deg(180 - 130.3635), deg(180 - 113.7578))
                ctxHead.arc(17.17, 36.97, 12, deg(180 - 113.7578), deg(180 - 61.8275))
                ctxHead.arc(2.06, 65.18, 20, deg(270 + 28.1725), deg(270 + 5.5738), true)
                ctxHead.arc(-4.26, 129.87, 85, deg(270 + 5.5738), deg(270 + 2.87), true)
                ctxHead.lineTo(0, 5.02)
                ctxHead.fill()

                ctxHead.fillStyle = '#5A7D59'
                ctxHead.beginPath()
                ctxHead.arc(30.5, 15, 4, deg(90), deg(300))
                ctxHead.lineTo(38.5, 15)
                ctxHead.arc(37.5, 16.73, 2, deg(300), deg(87.7958))
                ctxHead.lineTo(30.5, 19)
                ctxHead.fill()

                ctxHead.beginPath()
                ctxHead.fillStyle = '#395138'
                ctxHead.arc(35, 16.11, 2.71, deg(0), deg(360))
                ctxHead.fill()


                ctxHead.beginPath()
                ctxHead.fillStyle = '#395138'
                ctxHead.arc(47, 23, .5, deg(0), deg(360))
                ctxHead.fill()

                ctxHead.fillStyle = '#5A7D59'
                ctxHead.beginPath()
                ctxHead.arc(30.5, 35, 4, deg(60), deg(270))
                ctxHead.lineTo(37.58, 31.27)
                ctxHead.arc(37.5, 33.27, 2, deg(267.7958), deg(60))
                ctxHead.lineTo(32.5, 38.46)
                ctxHead.fill()

                ctxHead.fillStyle = '#395138'
                ctxHead.beginPath()
                ctxHead.arc(35, 33.89, 2.71, deg(0), deg(360))
                ctxHead.fill()

                ctxHead.beginPath()
                ctxHead.fillStyle = '#395138'
                ctxHead.arc(47, 27, .5, deg(0), deg(360))
                ctxHead.fill()
                ctxHead.restore()
                ctxHead.restore()
            }


        }
        var lastKey
        function snakeConectionFunc() {

            //snakeConection.display = 'none'
            let kls = 0

            if (lastKey != actualDirection) {
                switch (actualDirection) {
                    case 'w':
                        snakeConection.transform = 'rotate(0deg)'
                        snakeConection.top = '50px'
                        snakeConection.left = '5px'
                        if (hasBody && actualDirection === 'w') { snakeConection.display = 'block' }
                        break
                    case 's':
                        snakeConection.transform = 'rotate(0deg)'
                        snakeConection.top = '-10px'
                        snakeConection.left = '5px'
                        if (hasBody && actualDirection === 's') { snakeConection.display = 'block' }
                        break
                    case 'a':
                        snakeConection.transform = 'rotate(90deg)'
                        snakeConection.top = '20px'
                        snakeConection.left = '35px'
                        if (hasBody && actualDirection === 'a') { snakeConection.display = 'block' }
                        break
                    case 'd':
                        snakeConection.transform = 'rotate(90deg)'
                        snakeConection.top = '20px'
                        snakeConection.left = '-25px'
                        if (hasBody && actualDirection === 'd') { snakeConection.display = 'block' }
                        break
                }
                lastKey = actualDirection
            }
        }

        var lastBodyStatus = { x: 'none', y: 'none', lastX: 'none', lastY: 'none' }
        function lastBodyDirection() {
            let lastIndex = bodyArray.length - 1
            let penultimateIndex = bodyArray.length - 2
            let log = false
            try {
                if (lastBodyStatus.lastY != bodyArray[lastIndex].top) {
                    if (bodyArray[lastIndex].left > bodyArray[penultimateIndex].left) {
                        //console.log('LEFT')
                        if (lastBodyStatus.y === 'top') {
                            lastBodyStatus.lastY = bodyArray[lastIndex].top
                            if (log) { console.log('baixo para cima /// indo para esquerda') }
                            drawLast(-180, '-', 'left top')
                            //drawLast(0, '-')
                        }
                        else if (lastBodyStatus.y === 'bottom') {
                            lastBodyStatus.lastY = bodyArray[lastIndex].top
                            if (log) { console.log('cima para baixo /// indo para esquerda') }
                            drawLast(180, '+')
                            //drawLast()
                        }
                        lastBodyStatus.x = 'left'
                    }
                    else if (bodyArray[lastIndex].left < bodyArray[penultimateIndex].left) {
                        //console.log('RIGHT')
                        if (lastBodyStatus.y === 'top') {
                            lastBodyStatus.lastY = bodyArray[lastIndex].top
                            if (log) { console.log('baixo para cima /// indo para direita') }
                            drawLast(0, '+')
                        }
                        else if (lastBodyStatus.y === 'bottom') {
                            lastBodyStatus.lastY = bodyArray[lastIndex].top
                            if (log) { console.log('cima para baixo /// indo para direita') }
                            drawLast(0, '-')
                        }
                        lastBodyStatus.x = 'right'
                    }
                    //console.log(lastBodyStatus)
                }
                else if (lastBodyStatus.lastX != bodyArray[lastIndex].left) {
                    if (bodyArray[lastIndex].top > bodyArray[penultimateIndex].top) {
                        //console.log('TOP')
                        if (lastBodyStatus.x === 'left') {
                            lastBodyStatus.lastX = bodyArray[lastIndex].left
                            if (log) { console.log('indo para esquerda /// baixo para cima') }
                            drawLast(270, '+')
                        }
                        else if (lastBodyStatus.x === 'right') {
                            lastBodyStatus.lastX = bodyArray[lastIndex].left
                            if (log) { console.log('indo para direita /// baixo para cima') }
                            drawLast(-90, '-', 'center top')
                        }
                        lastBodyStatus.y = 'top'

                    }
                    else if (bodyArray[lastIndex].top < bodyArray[penultimateIndex].top) {
                        //console.log('BOTTOM')
                        if (lastBodyStatus.x === 'left') {
                            lastBodyStatus.lastX = bodyArray[lastIndex].left
                            if (log) { console.log('indo para esquerda /// cima para baixo') }
                            drawLast(-270, '-')
                        }
                        else if (lastBodyStatus.x === 'right') {
                            lastBodyStatus.lastX = bodyArray[lastIndex].left
                            if (log) { console.log('indo para direita /// cima para baixo') }
                            drawLast(90, '+')

                        }
                        lastBodyStatus.y = 'bottom'
                    }
                    //console.log(lastBodyStatus)
                }
            } catch { console.log('TNC') }
        }

        var lastAnimationBody = { angle: 0, type: 'none', pivot: 'none' }
        var lastTypeBody
        var angleBody = 0
        var lastAngleBody = 0
        var isOriginBody = false
        var isBodyAnimation = false
        var abc = 0
        var asd = 0
        function drawLast(angle, type, pivot) {
            lastBody = document.getElementById('last-body')

            lastAnimationBody.angle = angle
            lastAnimationBody.type = type
            lastAnimationBody.pivot = pivot

            //lastBody.style.transformOrigin = 'center top'

            if (lastTypeBody != type && lastTypeBody != undefined && lastAngleBody != 0) {

                if (type === '-') {
                    angleBody -= 360
                    lastAngleBody -= 360
                }
                else {
                    angleBody += 360
                    lastAngleBody += 360
                }
            }

            lastTypeBody = lastTypeBody === type ? lastTypeBody : type
            type = type === '-' ? -1 : 1

            if (angle === 0 && positiveNumber(angleBody) >= 270) {
                angle = 360 * type
                isOriginBody = true
            }

            if (angle != angleBody) {
                isBodyAnimation = true
                //console.log(angle)
                //console.log('angle: ' + angle + ' /// ' + 'angleBody: ' + angleBody)
            }
            else {
                isBodyAnimation = false
                abc = 0
                if (pivot === 'center top') {
                    //lastBody.style.transformOrigin = 'center center'
                }
                lastAngleBody = angle
                //canvasHead.style.transformOrigin = 'center center'
                if (isOriginBody) {
                    angleBody = 0
                    lastAngleBody = 0
                    isOriginBody = false
                }
            }

            abc += 5

            if (abc > 25) {

                // clearAllInterval()
                // window.cancelAnimationFrame(isMoving)
                // isCollidingBody = true

                if (angle != undefined && isBodyAnimation == true) {
                    angleBody += ((absoluteValue(lastAngleBody, angle)) * type) / 5
                    //console.log('angleBody: ' + angleBody)
                }
                lastBody.style.transform = 'rotate(' + (angleBody) + 'deg)'
            }


            onlyDrawLast()

        }
        function onlyDrawLast() {
            canvasLastBody = document.getElementById('canvas-last-body')
            let ctx = canvasLastBody.getContext('2d')

            if (canvasLastBody.getContext) {
                ctx.clearRect(0, 0, 60, 60)
                ctx.save()
                ctx.translate(10, 5)
                // ctx.fillStyle = 'purple'
                // ctx.beginPath()
                // ctx.arc(25, 25, 20, deg(90), deg(270))
                // ctx.lineTo(25, 0)
                // ctx.lineTo(-10, 0)
                // ctx.lineTo(-10, 50)
                // ctx.lineTo(25, 50)
                // ctx.lineTo(25, 45)
                // ctx.fill()


                ctx.fillStyle = 'green'
                ctx.beginPath()
                ctx.arc(25, 25, 20, deg(90), deg(270))
                ctx.lineTo(45, 5)
                ctx.lineTo(45, 45)
                ctx.lineTo(25, 45)
                ctx.lineTo(25, 35)
                ctx.fill()
                ctx.restore()
            }
        }
        function deg(value) {
            return value * (Math.PI / 180)
        }
    </script>

    <style>
        body,
        html {
            z-index: 10;
        }

        .nav {
            width: 1400px;
            height: 150px;
            background-color: lightgray;
            z-index: 11;
        }

        #map {
            width: 1400px;
            height: 600px;
            background-color: gray;
            position: relative;
        }

        #snake {
            width: 50px;
            height: 50px;
            /* background-color: green; */
            position: absolute;
        }

        #snake-head {
            position: absolute;
            z-index: 10;
            width: 50px;
            height: 50px;
        }

        #canvas-head {
            transform: translate(-5px, -5px);
        }

        #snake-conection {
            width: 40px;
            height: 10px;
            background-color: green;
            position: absolute;
            display: none;
        }

        #last-body {
            width: 50px;
            height: 50px;
            position: absolute;
            z-index: 2;
            /* background-color: purple; */
        }

        #canvas-last-body {
            transform: translate(-5px, -5px);
        }

        .snake-body {
            width: 50px;
            height: 50px;
            position: absolute;
        }

        .snake-body-style {
            width: 50px;
            height: 50px;
            background-color: green;
            /* transition-duration: .01s; */
            position: absolute;
            z-index: 1;
        }

        .food {
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
            z-index: 6;
        }

        .way {
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }

        .fillet {
            position: absolute;
            z-index: 5;
        }

        .fill {
            position: absolute;
            z-index: 4;
        }
    </style>
</head>

<body>


    <main class="d-flex justify-content-center flex-wrap">
        <div class="nav d-block">
            <h1 id="h1-nav"></h1>
            <h2 id="h2-nav"></h2>
        </div>
        <div id="map">

            <div id="snake">
                <span id="snake-head">
                    <canvas width="60px" height="60px" id="canvas-head"></canvas>
                </span>
                <span id="snake-conection"></span>
            </div>

            <div id="last-body">
                <canvas width="60px" height="60px" id="canvas-last-body"></canvas>
            </div>

            <div class="food" id="food"></div>

        </div>
    </main>

    <script>
        var pressed = document.getElementById('pressed')
        var lastBody = document.getElementById('last-body')
        var canvasLastBody = document.getElementById('canvas-last-body')
        var snakeHead = document.getElementById('snake-head')
        var canvasHead = document.getElementById('canvas-head')

        canvasHead.addEventListener('onload', drawHead())
        canvasLastBody.addEventListener('onload', onlyDrawLast())

        var snakePos = document.getElementById('snake').style
        var snakeConection = document.getElementById('snake-conection').style

        var foodPos = document.getElementById('food').style

        var snakePosGet = window.getComputedStyle(document.getElementById('snake'))
        var foodPosGet = window.getComputedStyle(document.getElementById('food'))

        initiate()
        randomPosition() //Alterar posição da comida inicial
    </script>
</body>

</html>