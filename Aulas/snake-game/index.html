<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa"
        crossorigin="anonymous"></script>

    <!-- fontawesome -->
    <script src="https://kit.fontawesome.com/490ac8585b.js" crossorigin="anonymous"></script>


    <script>
        var stepToCSS = 'px'
        var stepToCalc = 50
        var step = 5

        var leftPos = 0
        var topPos = 0
        var timeDelay = 150

        var isMoving
        var lastInput

        var actualDirection = null

        var ms = timeDelay / 10
        var temp = null
        var timeInputs
        var timeBetweenInputs = 0
        var firstKey = false
        var counter = 0
        var numberKeysDown = 0

        var lastPosTop = 0
        var lastPosLeft = 0

        var score = 0

        var isExecutingW = false
        var isExecutingS = false
        var isExecutingA = false
        var isExecutingD = false
        var isExecutingContinuos = false

        var singleInput = false

        var arrayKeys = new Array()
        var arrayBody = new Array()

        var moveKeys = /[wsad]/i
        document.onkeydown = function (asd) {
            if (asd.key.match(moveKeys) && asd.key.length === 1) {
                moveSnake(asd.key)
                firstKey = true

                counter = 0
                if (numberKeysDown % 2 === 0) { //Contador para evitar dupla inserção de teclas
                    if (timeInputs === undefined) {
                        timeInputs = setInterval(
                            function () {
                                counter++
                                //document.getElementById('h1-nav').innerHTML = counter
                            }, 1
                        )
                    }
                }
                numberKeysDown++
            }
            else if (asd.key == 'p') {
                if (isMoving != undefined) {
                    window.cancelAnimationFrame(isMoving)
                    isMoving = undefined
                }
                else {
                    moveSnake(asd.key)
                }
            }
            else if (asd.key == 'm') {
                singleInput = singleInput === false ? true : false
            }

        }

        var posString = ''
        var operationString = ''
        var isLeft = false
        var isValid = false

        function notExecuting() {
            isExecutingW = false
            isExecutingS = false
            isExecutingA = false
            isExecutingD = false
        }
        function isExecuting() {
            if (isExecutingW === true || isExecutingS === true || isExecutingA === true || isExecutingD === true || isExecutingContinuos === true) {
                return true
            }
            else {
                return false
            }
        }


        var lastPosBodyLeft
        var lastPosBodyTop
        var arrayLastPositions = new Array()
        var lengthBody = 10
        var isEating = false

        var lastPosTopSnake
        var lastPosLeftSnake
        var endCycle = 0
        var statusDirection = { x: 'none', y: 'none', lastX: 'none', lastY: 'none' }

        function canMove(firstTarget, secondTarget, operation) {

            arrayLastPositions.push({ left: leftPos, top: topPos })

            lengthBody = score === 0 ? lengthBody : 10 * (score + 1)

            let indexLocal = lengthBody - 11 < 0 ? 0 : lengthBody - 11


            if (arrayLastPositions.length === lengthBody || isEating === true) { //Continuos

                if (indexLocal != 0 && arrayLastPositions.length === lengthBody) { arrayLastPositions.shift(); isEating = false }
                lastPosLeft = arrayLastPositions[indexLocal].left
                lastPosTop = arrayLastPositions[indexLocal].top
                if (indexLocal === 0 && arrayLastPositions.length === lengthBody) { arrayLastPositions.shift() }
            }


            if (bodySet.length === 0) {
                lastPosBodyLeft = lastPosLeft
                lastPosBodyTop = lastPosTop
            }

            if (operation == '+') {
                if (firstTarget == 'leftPos') {
                    leftPos += step
                }
                else {
                    topPos += step
                }
            }
            else {
                if (firstTarget == 'leftPos') {
                    leftPos -= step
                }
                else {
                    topPos -= step
                }
            }

            lastPosLeftSnake = lastPosLeftSnake === undefined ? leftPos : lastPosLeftSnake
            lastPosTopSnake = lastPosTopSnake === undefined ? topPos : lastPosTopSnake

            if (hasBody) { filletBodyApply() }

            colissionBody()

            if (leaveMap()) {
                clearAllInterval()
                window.cancelAnimationFrame(isMoving)
            }
            else if (isCollidingBody === false && isExecutingContinuos === false) {

                snakePos = document.getElementById('snake').style

                if (secondTarget === true) {
                    snakePos.left = leftPos + stepToCSS
                }
                else {
                    snakePos.top = topPos + stepToCSS
                }

                if (leftPos % 50 === 0 && topPos % 50 === 0) {
                    //Adiciona posição à lista de banimento de posicionamento para a comida, pois está em uso
                    indexThereSomething.push(coordToIndex(Math.round(leftPos / 50) * 50, Math.round(topPos / 50) * 50))
                    //console.log(indexThereSomething)
                }
            }
        }


        function defaultMove() {

            if (leftPos % 50 === 0 && topPos % 50 === 0) {
                if (arrayKeys.length != 0) {
                    whichDirection(arrayKeys[0])
                    arrayKeys.shift()
                }


                if (arrayLastKeys.length != 0) {
                    whichDirection(arrayLastKeys[0])
                    arrayLastKeys.shift()
                }
            }

            notExecuting()

            canMove(posString, isLeft, operationString)


            if (leaveMap() === false && isCollidingBody === false) {

                bodySnakeApply()

                collisionFood()

                snakeConectionFunc()

                if (hasBody === false && indexThereSomething.length > 1) {
                    //console.log('INDEX RETIRADO SE NÃO HAVER CORPO: ' + indexThereSomething[0])
                    indexThereSomething.shift()
                    //console.log(indexThereSomething)
                }
                if (singleInput === false) { isMoving = window.requestAnimationFrame(defaultMove) }
                else if (repeat < stepToCalc - 5) {
                    window.requestAnimationFrame(defaultMove)
                    //console.log('BBBBB: ' + repeat)
                    repeat += step
                }
            }

        }

        var repeat = 0
        var arrayLastKeys = new Array()

        function moveSnake(directionLocal) {

            if (leftPos % 50 === 0 && topPos % 50 === 0) {
                if (arrayLastKeys.length === 0) {
                    whichDirection(directionLocal)
                }
            }
            else {
                arrayLastKeys.push(directionLocal)
            }

            if (singleInput === true) {
                repeat = 0
                defaultMove()
            }
            else {
                if (isMoving === undefined) {
                    if (isValid === true) {
                        isMoving = window.requestAnimationFrame(defaultMove)
                    }
                }
            }
        }

        function whichDirection(direction) {
            //console.log('DIRECTION: ' + direction)
            //console.log('arrayKEYS: ' + arrayKeys)
            switch (direction) {

                case 'w':
                    if (actualDirection != 's' && isExecuting() === false) {
                        isExecutingW = true
                        posString = 'topPos'
                        operationString = '-'
                        isLeft = false
                        actualDirection = 'w'
                        //console.log('W')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('W')
                        arrayKeys.push(direction)
                    }
                    break

                case 's':
                    if (actualDirection != 'w' && isExecuting() === false) {
                        isExecutingS = true
                        posString = 'topPos'
                        operationString = '+'
                        isLeft = false
                        actualDirection = 's'
                        //console.log('S')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('S')
                        arrayKeys.push(direction)
                    }
                    break

                case 'a':
                    if (actualDirection != 'd' && isExecuting() === false) {
                        isExecutingA = true
                        posString = 'leftPos'
                        operationString = '-'
                        isLeft = true
                        actualDirection = 'a'
                        //console.log('A')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('A')
                        arrayKeys.push(direction)
                    }
                    break

                case 'd':
                    if (actualDirection != 'a' && isExecuting() === false) {
                        isExecutingD = true
                        posString = 'leftPos'
                        operationString = '+'
                        isLeft = true
                        actualDirection = 'd'
                        //console.log('D')
                        isValid = true
                    }
                    else {
                        isValid = false
                        //console.log('D')
                        arrayKeys.push(direction)
                    }
                    break
            }
        }
        function clearAllInterval() {
            clearInterval(temp)
            clearInterval(timeInputs)
        }
        function leaveMap() {
            if (leftPos < 0 || leftPos > 1400 - stepToCalc || topPos < 0 || topPos > 600 - stepToCalc) {
                return true
            }
            else {
                return false
            }
        }

        var isCollidingBody = false

        function colissionBody() {

            if (hasBody === true) {

                bodySnakeComputed()

                if (bodySet.length > 2) {
                    for (let i = 0; i < bodySet.length; i++) {


                        if (i != bodySet.length - 1) {
                            if (positiveNumber(bodyArray[i].left - roundByDirection(leftPos)) < 50 &&
                                positiveNumber(bodyArray[i].top - roundByDirection(topPos)) < 50) {
                                isCollidingBody = true
                                break
                            }
                        }
                        else {
                            if (positiveNumber(bodyArray[i - 1].left - roundByDirection(leftPos)) < 50 &&
                                positiveNumber(bodyArray[i - 1].top - roundByDirection(topPos)) < 50) {
                                isCollidingBody = true
                                break
                            }
                        }
                    }
                }
            }
        }
        function collisionFood() {

            redeclareConst()

            if (snakePosGet.top === foodPosGet.top && snakePosGet.left === foodPosGet.left) {

                randomPosition()

                hasBody = true

                document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + lastPosBodyLeft + stepToCSS + '; top: ' + lastPosBodyTop + stepToCSS + '"><span class="snake-body-style"></span></span>'


                redeclareConst()
                drawAll()

                isEating = true
                score++
                document.getElementById('h1-nav').innerHTML = score
            }

        }
        function redeclareConst() {
            snakePos = document.getElementById('snake').style
            snakeConection = document.getElementById('snake-conection').style
            foodPos = document.getElementById('food').style
            snakePosGet = window.getComputedStyle(document.getElementById('snake'))
            foodPosGet = window.getComputedStyle(document.getElementById('food'))
        }

        var mapWidth
        var mapHeight
        var allPos = []
        var allIndex = []
        function initiate() {

            mapWidth = 1400 - stepToCalc
            mapHeight = 600 - stepToCalc

            let i = 0

            for (let x = 0; x <= mapWidth; x += stepToCalc) {
                for (let y = 0; y <= mapHeight; y += stepToCalc) {
                    allPos.push({ left: x, top: y })
                    allIndex.push(i)
                    i++
                }
            }
            console.log(allPos)
        }

        function checkThereSomething(value) {

            let there = false

            for (let i = 0; i < indexThereSomething.length; i++) {
                if (indexThereSomething[i] === value) {
                    there = true
                    break
                }
            }
            if (there === false) { return value }
        }

        function randomNumber() {

            let tempAllIndex = allIndex.filter(checkThereSomething)

            let value = tempAllIndex[Math.floor(Math.random() * tempAllIndex.length)]
            //console.log(tempAllIndex)
            //console.log(value)
            return value
        }

        var indexThereSomething = []

        function randomPosition() {


            let index = randomNumber()
            foodPos.left = allPos[index].left + stepToCSS
            foodPos.top = allPos[index].top + stepToCSS

        }

        function coordToIndex(left, top) {

            let x1 = left / 50 * 12
            let y1 = top / 50
            let temp

            if (y1 == 0) {
                temp = x1
            }
            else {
                temp = Number(x1 + y1)
            }

            return temp
        }

        var bodyArray = new Array()
        const bodySet = document.getElementsByClassName('snake-body')
        const bodySetStyle = document.getElementsByClassName('snake-body-style')

        var hasBody = false
        var indexToCalculateFillet = 0
        var auxIndexLast = 0
        var auxIndexOthers = 0

        function bodySnakeComputed() {

            for (let i = 0; i < bodySet.length; i++) {

                if (i != bodySet.length - 1) {
                    if (isEating) {
                        bodyArray[i] = arrayLastPositions[lengthBody - (10 * i) - 20 + auxIndexOthers]
                    }
                    else {
                        bodyArray[i] = arrayLastPositions[lengthBody - (10 * i) - 11]
                    }

                }
                else {
                    if (isEating) {
                        auxIndexOthers++
                        bodyArray[i] = arrayLastPositions[auxIndexLast]
                        if (auxIndexLast === 9) {
                            isEating = false
                            auxIndexLast = 0
                            auxIndexOthers = 0
                        }
                        else {
                            auxIndexLast++
                        }
                    }
                    else {
                        bodyArray[i] = arrayLastPositions[9]
                    }

                    lastPosBodyLeft = arrayLastPositions[0].left
                    lastPosBodyTop = arrayLastPositions[0].top


                    try {
                        if (leftPos % 50 === 0 && topPos % 50 === 0) {

                            if (bodyArray[i].left === allPos[indexThereSomething[1]].left &&
                                bodyArray[i].top === allPos[indexThereSomething[1]].top) {

                                indexThereSomething.shift()

                            }
                        }
                    } catch { }
                }


                if (i === 1) {
                    indexToCalculateFillet = lengthBody - (10 * i) - 11
                }
            }
        }

        function clearUn(value) {
            return Number(value.replace('px', ''))
        }

        function roundValue(value) {
            return Math.round(value / 50) * 50
        }

        function positiveNumber(value) {
            if (value < 0) {
                return value * -1
            }
            else {
                return value
            }
        }

        function roundByDirection(value) {

            let a

            switch (actualDirection) {
                case 'w':
                    a = Math.floor(value / 50) * 50
                    break
                case 's':
                    a = Math.ceil(value / 50) * 50
                    break
                case 'a':
                    a = Math.floor(value / 50) * 50
                    break
                case 'd':
                    a = Math.ceil(value / 50) * 50
                    break
            }
            return a
        }


        function filletBodyApply() {
            if (lastPosLeftSnake != leftPos && endCycle === 0) {
                endCycle++
                if (statusDirection.lastY != topPos) {
                    if (lastPosLeftSnake > leftPos) {
                        //console.log('INDO PARA ESQUERDA')
                        if (statusDirection.y === 'top') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 0, 5, -5, bodyArray.length)
                            //snakePos.backgroundColor = 'red'
                            statusDirection.lastY = topPos
                        }
                        else if (statusDirection.y === 'bottom') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 90, 5, 5, bodyArray.length)
                            //snakePos.backgroundColor = 'blue'
                            statusDirection.lastY = topPos
                        }
                        statusDirection.x = 'left'
                    }
                    else if (lastPosLeftSnake < leftPos) {
                        //console.log("INDO PARA DIREITA")
                        if (statusDirection.y === 'top') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 270, -5, -5, bodyArray.length)
                            //snakePos.backgroundColor = 'orange'
                            statusDirection.lastY = topPos
                        }
                        else if (statusDirection.y === 'bottom') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 180, -5, 5, bodyArray.length)
                            //snakePos.backgroundColor = 'white'
                            statusDirection.lastY = topPos
                        }
                        statusDirection.x = 'right'
                    }
                }

                lastPosLeftSnake = leftPos
            }
            else if (lastPosTopSnake != topPos && endCycle === 0 && bodySet.length > 0) {
                endCycle++
                //console.log('TOP DIFERENTE')

                if (statusDirection.lastX != leftPos) {
                    if (lastPosTopSnake > topPos) {
                        //console.log('INDO PARA CIMA')
                        if (statusDirection.x === 'left') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 180, -5, 5, bodyArray.length)
                            //snakePos.backgroundColor = 'lightblue'
                            statusDirection.lastX = leftPos
                        }
                        else if (statusDirection.x === 'right') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 90, 5, 5, bodyArray.length)
                            //snakePos.backgroundColor = 'darkred'
                            statusDirection.lastX = leftPos
                        }
                        statusDirection.y = 'top'
                    }
                    else if (lastPosTopSnake < topPos) {
                        //console.log('INDO PARA BAIXO')
                        if (statusDirection.x === 'left') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 270, -5, -5, bodyArray.length)
                            //snakePos.backgroundColor = 'green'
                            statusDirection.lastX = leftPos
                        }
                        else if (statusDirection.x === 'right') {
                            drawFillet(lastPosTopSnake, lastPosLeftSnake, 0, 5, -5, bodyArray.length)
                            //snakePos.backgroundColor = 'purple'
                            statusDirection.lastX = leftPos
                        }
                        statusDirection.y = 'bottom'
                    }
                }
                lastPosTopSnake = topPos
            }

            if (endCycle != 0) {
                if (leftPos % 50 === 0 && topPos % 50 === 0) {
                    endCycle = 0
                    lastPosLeftSnake = leftPos
                    lastPosTopSnake = topPos
                }
            }
        }

        function bodySnakeApply() {

            let xy

            if (isCollidingBody === false) {

                for (let i = 0; i < bodySet.length; i++) {

                    xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[i])


                    if (bodyArray[i].left != clearUn(xy.left) && bodyArray[i].top == clearUn(xy.top)) {
                        bodySetStyle[i].style.width = '60px'
                        bodySetStyle[i].style.height = '40px'
                        bodySet[i].style.left = bodyArray[i].left + stepToCSS
                    }

                    if (bodyArray[i].top != clearUn(xy.top) && bodyArray[i].left == clearUn(xy.left)) {
                        bodySetStyle[i].style.width = '40px'
                        bodySetStyle[i].style.height = '60px'
                        bodySet[i].style.top = bodyArray[i].top + stepToCSS
                    }

                    if (i === bodySet.length - 1) {

                        if (filletPosition.length != 0 && bodyArray[i].top === filletPosition[0].top && bodyArray[i].left === filletPosition[0].left) {

                            setTimeout(
                                function () {
                                    let fill = document.getElementsByClassName('fill')[0]
                                    if (leaveMap() === false && isCollidingBody === false) { fill.remove() }
                                }, timeDelay / 3
                            )
                            setTimeout(
                                function () {
                                    let fillet = document.getElementsByClassName('fillet')[0]
                                    if (leaveMap() === false && isCollidingBody === false) { fillet.remove() }
                                }, timeDelay + 100
                            )
                            filletPosition.shift()
                        }
                    }
                }
            }
        }

        var filletPosition = []

        function drawFillet(posTop, posLeft, rotate, transX, transY, time) {

            document.getElementById('map').innerHTML += '<canvas class="fillet" width=50px height=50px></canvas>'
            document.getElementById('map').innerHTML += '<canvas class="fill" width=50px height=50px></canvas>'

            drawAll()

            let filletLocal = document.getElementsByClassName('fillet')[document.getElementsByClassName('fillet').length - 1]
            let fillLocal = document.getElementsByClassName('fill')[document.getElementsByClassName('fill').length - 1]


            filletPosition.push({ left: posLeft, top: posTop })


            filletLocal.style.left = (posLeft + transX) + stepToCSS
            filletLocal.style.top = (posTop + transY) + stepToCSS
            filletLocal.style.transform = 'rotate(' + rotate + 'deg)'

            fillLocal.style.left = posLeft + stepToCSS
            fillLocal.style.top = posTop + stepToCSS

            redeclareConst()
        }

        function drawAll() {
            for (let x = 0; x < document.getElementsByClassName('fillet').length; x++) {

                let fillet = document.getElementsByClassName('fillet')[x]
                let ctx = fillet.getContext('2d')

                if (fillet.getContext) {
                    ctx.fillStyle = 'gray'
                    ctx.beginPath();
                    ctx.lineTo(50, 0)
                    ctx.lineTo(50, 50)
                    ctx.lineTo(40, 50)
                    ctx.arc(0, 50, 40, 0 * (Math.PI / 180), 270 * (Math.PI / 180), true)
                    ctx.lineTo(0, 0)
                    ctx.fill()
                }

                try {
                    let fill = document.getElementsByClassName('fill')[x]
                    let ctxFill = fill.getContext('2d')

                    if (fill.getContext) {
                        ctxFill.fillStyle = 'rgb(38, 8, 189)'
                        ctxFill.fillRect(10, 10, 30, 30)
                    }
                } catch { }
            }
        }

        var lastKey
        function snakeConectionFunc() {

            //snakeConection.display = 'none'
            let kls = 0

            if (lastKey != actualDirection) {
                switch (actualDirection) {
                    case 'w':
                        setTimeout(
                            function () {
                                snakeConection.transform = 'rotate(0deg)'
                                snakeConection.top = '50px'
                                snakeConection.left = '5px'
                                if (hasBody && actualDirection === 'w') { snakeConection.display = 'block' }
                            }, kls
                        )
                        break
                    case 's':
                        setTimeout(
                            function () {
                                snakeConection.transform = 'rotate(0deg)'
                                snakeConection.top = '-10px'
                                snakeConection.left = '5px'
                                if (hasBody && actualDirection === 's') { snakeConection.display = 'block' }
                            }, kls
                        )
                        break
                    case 'a':
                        setTimeout(
                            function () {
                                snakeConection.transform = 'rotate(90deg)'
                                snakeConection.top = '20px'
                                snakeConection.left = '35px'
                                if (hasBody && actualDirection === 'a') { snakeConection.display = 'block' }
                            }, kls
                        )
                        break
                    case 'd':
                        setTimeout(
                            function () {
                                snakeConection.transform = 'rotate(90deg)'
                                snakeConection.top = '20px'
                                snakeConection.left = '-25px'
                                if (hasBody && actualDirection === 'd') { snakeConection.display = 'block' }
                            }, kls
                        )
                        break
                }
                lastKey = actualDirection
            }
        }
    </script>

    <style>
        body,
        html {
            z-index: 10;
        }

        .nav {
            width: 1400px;
            height: 150px;
            background-color: lightgray;
            z-index: 11;
        }

        #map {
            width: 1400px;
            height: 600px;
            background-color: gray;
            position: relative;
        }

        #snake {
            width: 50px;
            height: 50px;
            position: absolute;
        }

        #snake-head {
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: green;
            z-index: 10;
        }

        #snake-conection {
            width: 40px;
            height: 10px;
            background-color: rgb(38, 8, 189);
            position: absolute;
            display: none;
        }

        .snake-body {
            width: 50px;
            height: 50px;
            position: absolute;
        }

        .snake-body-style {
            width: 50px;
            height: 50px;
            background-color: rgb(38, 8, 189);
            /* transition-duration: .01s; */
            position: absolute;
            z-index: 0;
        }

        .food {
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
            z-index: 6;
        }

        .way {
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }

        .fillet {
            position: absolute;
            z-index: 5;
        }

        .fill {
            position: absolute;
            z-index: 4;
        }
    </style>
</head>

<body>


    <main class="d-flex justify-content-center flex-wrap">
        <div class="nav d-block">



            <h1 id="h1-nav"></h1>
            <h2 id="h2-nav"></h2>
        </div>
        <div id="map">

            <div id="snake">
                <span id="snake-head"></span>
                <span id="snake-conection"></span>
            </div>

            <div class="food" id="food"></div>

        </div>
    </main>

    <script>
        var pressed = document.getElementById('pressed')

        var snakePos = document.getElementById('snake').style
        var snakeConection = document.getElementById('snake-conection').style

        var foodPos = document.getElementById('food').style

        var snakePosGet = window.getComputedStyle(document.getElementById('snake'))
        var foodPosGet = window.getComputedStyle(document.getElementById('food'))
        initiate()
        randomPosition() //Alterar posição da comida inicial
    </script>
</body>

</html>