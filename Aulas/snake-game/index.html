<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>

    <!-- fontawesome -->
    <script src="https://kit.fontawesome.com/490ac8585b.js" crossorigin="anonymous"></script>


    <script>
        var stepToCSS = 'px'
        var stepToCalc = 50
        var step = 5

        var leftPos = 0
        var topPos = 0
        var timeDelay = 150
        
        var isMoving
        var lastInput

        var actualDirection = null

        var ms = timeDelay/10
        var temp = null
        var timeInputs
        var timeBetweenInputs = 0
        var firstKey = false
        var counter = 0
        var numberKeysDown = 0

        var lastPosTop = 0
        var lastPosLeft = 0

        var score = 0

        var isExecutingW = false
        var isExecutingS = false
        var isExecutingA = false
        var isExecutingD = false
        var isExecutingContinuos = false

        var singleInput = false

        var arrayKeys = new Array()
        var arrayBody = new Array()

        document.onkeydown = function(asd){
            if ((asd.key == 'a' || asd.key == 'w' || asd.key == 's' || asd.key == 'd') && (counter > timeBetweenInputs || firstKey === false)){

                //notExecuting()
                moveSnake(asd.key)
                firstKey = true

                counter = 0
                if (numberKeysDown % 2 === 0){ //Contador para evitar dupla inserção de teclas
                    if (timeInputs === undefined){
                        timeInputs = setInterval(
                            function(){
                                counter++
                                document.getElementById('h1-nav').innerHTML = counter
                            },1
                        )
                    }
                }

                numberKeysDown++
            }
            else if (asd.key == 'p'){
                if (isMoving != undefined){
                    window.cancelAnimationFrame(isMoving)
                    isMoving = undefined
                }
                else{
                    moveSnake(asd.key)
                }
            }
            else if(asd.key == 'm'){
                singleInput = singleInput === false ? true : false
            }

        }

        var posString = ''
        var operationString = ''
        var isLeft = false
        var isValid = false

        function notExecuting(){
            isExecutingW = false
            isExecutingS = false
            isExecutingA = false
            isExecutingD = false
        }
        function isExecuting(){
            if (isExecutingW === true || isExecutingS === true || isExecutingA === true || isExecutingD === true || isExecutingContinuos === true){
                return true
            }
            else{
                return false
            }
        }


        var lastPosBodyLeft
        var lastPosBodyTop
        var arrayLastPositions = new Array()
        var lengthBody = 10
        var isEating = false

        

        function canMove(firstTarget, secondTarget, operation){

            arrayLastPositions.push({left: leftPos, top: topPos})

            lengthBody = score === 0 ? lengthBody : 10 * (score + 1)

            // console.log('SCORE: ' + score)
            // console.log('lengthBody: ' + lengthBody)
            // console.log('bodyArray: ' + bodyArray.length)

            let indexLocal = lengthBody - 11 < 0 ? 0 : lengthBody - 11

            //console.log('INDEX: ' + indexLocal)

            if (arrayLastPositions.length === lengthBody || isEating === true){ //Continuos
                
                //console.log(JSON.parse(JSON.stringify(arrayLastPositions)))

                if (indexLocal != 0 && arrayLastPositions.length === lengthBody){arrayLastPositions.shift(); isEating = false}
                lastPosLeft = arrayLastPositions[indexLocal].left
                lastPosTop = arrayLastPositions[indexLocal].top
                if (indexLocal === 0 && arrayLastPositions.length === lengthBody){arrayLastPositions.shift()}

                //console.log(arrayLastPositions)

                // console.log('INDEX APLICADO: ' + indexLocal)
                // console.log('lastPosLeft: ' + lastPosLeft)
                // console.log('lastPosTop: ' + lastPosTop)
                // console.log(arrayLastPositions[indexLocal].top)
                // console.log('AFTER SHIFT')
            }
            else{

            }


            if (bodySet.length === 0){
                lastPosBodyLeft = lastPosLeft
                lastPosBodyTop = lastPosTop
            }

            if ( operation == '+'){
                if(firstTarget == 'leftPos'){
                    leftPos += step
                }
                else{
                    topPos += step
                }
            }
            else{
                if(firstTarget == 'leftPos'){
                    leftPos -= step
                }
                else{
                    topPos -= step
                }
            }




            colissionBody()

            if (leaveMap()){
                clearAllInterval()
                window.cancelAnimationFrame(isMoving)
            }
            else if (isCollidingBody === false && isExecutingContinuos === false){

                snakePos = document.getElementById('snake').style

                if(secondTarget === true){
                    //continuosMovement('left')
                    snakePos.left = leftPos + stepToCSS
                }
                else{
                    //continuosMovement('top')
                    snakePos.top = topPos + stepToCSS
                }

                //bodySnakeApply()

                //Adiciona posição à lista de banimento de posicionamento para a comida, pois está em uso
                indexThereSomething.push(coordToIndex(Math.round(leftPos/50)*50, Math.round(topPos/50)*50))
            }
        }


        function defaultMove(){

            if (arrayKeys.length != 0){
                whichDirection(arrayKeys[0])
                arrayKeys.shift()
            }


            if (arrayLastKeys.length != 0 && leftPos % 50 === 0 && topPos % 50 === 0){
                whichDirection(arrayLastKeys[0])
                arrayLastKeys.shift()
            }

            notExecuting()

            //clearInterval(intervalContinuos)



            canMove(posString, isLeft, operationString)
            

            if (leaveMap() === false && isCollidingBody === false){

                bodySnakeApply()

                collisionFood()
                
                snakeConectionFunc()

                if (hasBody === false){
                    indexThereSomething.shift()
                    //console.log(indexThereSomething)
                }
                if (singleInput === false){isMoving = window.requestAnimationFrame(defaultMove)}
                else if(repeat < stepToCalc - 5){
                    window.requestAnimationFrame(defaultMove)
                    //console.log('BBBBB: ' + repeat)
                    repeat += step
                }
            }


            //document.getElementById('map').innerHTML += '<span class="way" style="left:' + lastPosLeft + stepToCSS +'; top: ' + lastPosTop + stepToCSS +'"></span>'
            //redeclareConst()


        }
        var repeat = 0
        var arrayLastKeys = new Array()
        function moveSnake(directionLocal){

            if (leftPos % 50 === 0 && topPos % 50 === 0){
                if (arrayLastKeys.length === 0){
                    whichDirection(directionLocal)
                }
            }
            else{
                arrayLastKeys.push(directionLocal)
            }

            if (singleInput === true){
                repeat = 0
                defaultMove()
            }
            else{
                if (isMoving === undefined){
                    if (isValid === true){

                        isMoving = window.requestAnimationFrame(defaultMove)

                        // isMoving = setInterval(
                        //     function(){
                        //         defaultMove()
                        //     },
                        //     timeDelay
                        // )
                    }
                }
            }
        }

        function whichDirection(direction){
            //console.log('DIRECTION: ' + direction)
            //console.log('arrayKEYS: ' + arrayKeys)
            switch (direction){

                case 'w':
                    if (actualDirection != 's' && isExecuting() === false){
                        isExecutingW = true
                        posString = 'topPos'
                        operationString = '-'
                        isLeft = false
                        actualDirection = 'w'
                        //console.log('W')
                        isValid = true
                    }
                    else{
                        isValid = false
                        //console.log('W')
                        arrayKeys.push(direction)
                    }
                    break

                case 's':
                    if (actualDirection != 'w' && isExecuting() === false){
                        isExecutingS = true
                        posString = 'topPos'
                        operationString = '+'
                        isLeft = false
                        actualDirection = 's'
                        //console.log('S')
                        isValid = true
                    }
                    else{
                        isValid = false
                        //console.log('S')
                        arrayKeys.push(direction)
                    }
                    break

                case 'a':
                    if (actualDirection != 'd' && isExecuting() === false){
                        isExecutingA = true
                        posString = 'leftPos'
                        operationString = '-'
                        isLeft = true
                        actualDirection = 'a'
                        //console.log('A')
                        isValid = true
                    }
                    else{
                        isValid = false
                        //console.log('A')
                        arrayKeys.push(direction)
                    }
                    break
                
                case 'd':
                    if (actualDirection != 'a' && isExecuting() === false){
                        isExecutingD = true
                        posString = 'leftPos'
                        operationString = '+'
                        isLeft = true
                        actualDirection = 'd'
                        //console.log('D')
                        isValid = true
                    }
                    else{
                        isValid = false
                        //console.log('D')
                        arrayKeys.push(direction)
                    }
                    break              
            }
        }
        function clearAllInterval(){
            clearInterval(isMoving)
            clearInterval(temp)
            clearInterval(timeInputs)
        }
        function leaveMap(){
            if (leftPos < 0 || leftPos >= 1400 || topPos < 0 || topPos >= 600){ 
                console.log('LEAVE MAP')
                return true
            } 
            else{
                return false
            }
        }

        var isCollidingBody = false

        function colissionBody(){

            if (hasBody === true){

                bodySnakeComputed()

                // for (let i = 0; i < bodySet.length; i++){

                //     let xy = bodyArray

                //     if (xy[i].left === leftPos + stepToCSS && xy[i].top === topPos + stepToCSS){

                //         isCollidingBody = true
                //         break
                //         //isMoving = undefined
                //     }
                // }
            }
        }
        function collisionFood(){
            redeclareConst()

            if (snakePosGet.top === foodPosGet.top && snakePosGet.left === foodPosGet.left){

                randomPosition()

                hasBody = true

                document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + lastPosBodyLeft + stepToCSS +'; top: ' + lastPosBodyTop + stepToCSS +'"><span class="snake-body-style"></span></span>'

                redeclareConst()
                drawAll()

                isEating = true
                score++
            }  

        }
        function redeclareConst(){
            snakePos = document.getElementById('snake').style
            snakeConection = document.getElementById('snake-conection').style
            foodPos = document.getElementById('food').style
            snakePosGet = window.getComputedStyle(document.getElementById('snake'))
            foodPosGet = window.getComputedStyle(document.getElementById('food'))
        }

        var mapWidth
        var mapHeight
        var allPos = []
        var allIndex = []
        function initiate(){

            mapWidth = 700 - stepToCalc
            mapHeight = 600 - stepToCalc

            let i = 0

            for (let x = 0; x <= mapWidth; x += stepToCalc){
                    for (let y = 0; y <= mapHeight; y += stepToCalc){
                        allPos.push({left: x, top: y})
                        allIndex.push(i)
                        i++
                }
            }
            //console.log(allPos)
        }

        function checkThereSomething(value){
            
            let there = false

            for (let i = 0; i < indexThereSomething.length; i++){
                if (indexThereSomething[i] === value){
                    there = true
                    break
                }
            }
            
            if (there === false){return value}
        }

        function randomNumber(){

            let tempAllIndex = allIndex.filter(checkThereSomething)

            let value = tempAllIndex[Math.floor(Math.random() * tempAllIndex.length)]
            //console.log(tempAllIndex)
            //console.log(value)
            return value
        }
        
        var indexThereSomething = []

        function randomPosition(){


            // let index = randomNumber()
            // foodPos.left = allPos[index].left + stepToCSS
            // foodPos.top = allPos[index].top + stepToCSS

            var x = Math.floor(Math.random() * (7*2)) * 50
            var y = Math.floor(Math.random() * (6*2)) * 50


            foodPos.left = x + stepToCSS
            foodPos.top = y + stepToCSS
            
        }

        function coordToIndex(left, top){

            let x1 = left/50*12
            let y1 = top/50
            let temp

            if (y1 == 0){
                temp = x1
            }
            else{
                temp = Number(x1 + y1)
            }

            return temp
        }

        var bodyArray = new Array()
        const bodySet = document.getElementsByClassName('snake-body')
        const bodySetStyle = document.getElementsByClassName('snake-body-style')

        var hasBody = false
        var indexToCalculateFillet = 0
        function bodySnakeComputed(){

            let x = {p1: 0, p2: 0}
            let y = {p1: 0, p2: 0}
            let xy

            for (let i = 0; i < bodySet.length; i++){

                
               if (i != bodySet.length - 1){
                    bodyArray[i] = arrayLastPositions[lengthBody - (10 * i) - 11]
               }
               else{
                    bodyArray[i] = arrayLastPositions[9]
                    lastPosBodyLeft = roundValue(arrayLastPositions[0].left)
                    lastPosBodyTop = roundValue(arrayLastPositions[0].top)
               }
                
               if (i === 1){
                    indexToCalculateFillet = lengthBody - (10 * i) - 11
               }
            }
        }

        function clearUn(value){ 
            return Number(value.replace('px', ''))
        }

        function roundValue(value){
            return Math.round(value/50)*50
        }

        var arrayStatus = new Array()
        var statusPos

        function bodySnakeApply(){


            let xy
            let top
            let left
            

            if (isCollidingBody === false){

                for (let i = 0; i < bodySet.length; i++){

                    xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[i])
                    top = xy.top
                    left = xy.left

                    //console.log('LEFT: ' + '// ' + i + ' // ' + bodyArray[i].left + ' /// ' + clearUn(xy.left))
                    //console.log('TOP: ' + '// ' + i + ' // ' + bodyArray[i].top + ' /// ' + clearUn(xy.top))



                    if (bodyArray[i].left != clearUn(xy.left) && bodyArray[i].top == clearUn(xy.top)){
                        bodySetStyle[i].style.width = '60px'
                        bodySetStyle[i].style.height = '40px'
                        bodySet[i].style.left = bodyArray[i].left + stepToCSS
                        arrayStatus[i] = 'left'
                        statusPos = 'left'
                    }

                    if(bodyArray[i].top != clearUn(xy.top) && bodyArray[i].left == clearUn(xy.left)){
                        bodySetStyle[i].style.width = '40px'
                        bodySetStyle[i].style.height = '60px'
                        bodySet[i].style.top = bodyArray[i].top + stepToCSS
                        arrayStatus[i] = 'top'
                        statusPos = 'top'
                    }
                    if (i === 0){
                        console.log('----------------')
                        console.log('topPOS: ' + topPos)
                        console.log('leftPOS: ' + leftPos)
                        console.log('ROUND topPOS: ' + roundValue(topPos))
                        console.log('ROUND leftPOS: ' + roundValue(leftPos))
                        console.log('----------------')
                    }

                    if (i === 0 && 1 > 2){
                        
                       //console.log('TOPPOS: ' + topPos)
                       //console.log('LEFTPOS: ' + leftPos) 

                        //console.log(arrayLastPositions)

                        if (statusPos === 'left'){
                            // console.log('LEFT')
                            // console.log('leftPos: ' + leftPos)
                            // console.log('array LEFT: ' + arrayLastPositions[indexToCalculateFillet].left)
                            // console.log('topPos: ' + topPos)
                            // console.log('array TOP: ' + arrayLastPositions[indexToCalculateFillet].top)
                            // console.log('lengthBody: ' + lengthBody)
                            // console.log('LEFT')
                            // console.log(indexToCalculateFillet)
                            if (topPos > arrayLastPositions[indexToCalculateFillet].top){
                                if (leftPos > arrayLastPositions[indexToCalculateFillet].left){
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 0, 5, -5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'white'
                                }
                                else{
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 270, -5, -5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'green'
                                }
                            }
                            else if(topPos < arrayLastPositions[indexToCalculateFillet].top){
                                if (leftPos < arrayLastPositions[indexToCalculateFillet].left){
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 180, -5, 5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'red'
                                }
                                else{
                                    drawFillet(arrayLastPositions[arrayLastPositions.length - 1].top, arrayLastPositions[arrayLastPositions.length - 1].left, 90, 5, 5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'blue'
                                }
                            }
                        }
                        else{
                            // console.log('TOP')
                            // console.log('leftPos: ' + leftPos)
                            // console.log('array LEFT: ' + arrayLastPositions[indexToCalculateFillet].left)
                            // console.log('topPos: ' + topPos)
                            // console.log('array TOP: ' + arrayLastPositions[indexToCalculateFillet].top)
                            // console.log(indexToCalculateFillet)
                            // console.log('TOP')
                            if (leftPos > arrayLastPositions[indexToCalculateFillet].left){
                                if (topPos > arrayLastPositions[indexToCalculateFillet].top){
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 180, -5, 5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'orange'
                                }
                                else{
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 270, -5, -5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'purple'
                                }
                            }
                            else if(leftPos < arrayLastPositions[indexToCalculateFillet].left){
                                if (topPos < arrayLastPositions[indexToCalculateFillet].top){
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 0, 5, -5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'darkred'
                                }
                                else{
                                    drawFillet(bodyArray[i].top, bodyArray[i].left, 90, 5, 5, bodyArray.length)
                                    bodySetStyle[i].style.backgroundColor = 'lightblue'
                                }
                            }
                        }
                    }

                    if (filletPosition.length != 0 && i === bodySet.length - 1){

                        // if (bodyArray[i].top === filletPosition[0].top && bodyArray[i].left === filletPosition[0].left){
                        //     setTimeout(
                        //         function(){
                        //             let fillet = document.getElementsByClassName('fillet')[0]
                        //             if(leaveMap() === false && isCollidingBody === false){fillet.remove()}
                        //         }, timeDelay + 200
                        //     )
                        //     filletPosition.shift()
                        // }
                    }
                }
            }
        }

        var filletPosition = []

        function drawFillet(posTop, posLeft, rotate, transX, transY, time){

            document.getElementById('map').innerHTML += '<canvas class="fillet" width=50px height=50px></canvas>'

            drawAll()

            let filletLocal = document.getElementsByClassName('fillet')[document.getElementsByClassName('fillet').length - 1]
            let timing

            timing = bodyArray.length * timeDelay + timeDelay/2

            filletPosition.push({left: posLeft, top: posTop})


            filletLocal.style.left = (posLeft + transX) + stepToCSS
            filletLocal.style.top = (posTop + transY) + stepToCSS
            filletLocal.style.transform = 'rotate(' + rotate + 'deg)'


            // setTimeout(
            //     function(){
            //         let fillet = document.getElementsByClassName('fillet')[0]
            //         if(leaveMap() === false && isCollidingBody === false){fillet.remove()}
            //         filletPosition.shift()
            //         contFillet--
            //     }, timing
            // )

            
            redeclareConst()
        }

        function drawAll(){
            for (let x = 0; x < document.getElementsByClassName('fillet').length; x++){
                let fillet = document.getElementsByClassName('fillet')[x]
                let ctx = fillet.getContext('2d')

                if (fillet.getContext){
                    ctx.fillStyle = 'black'
                    ctx.beginPath();
                    ctx.lineTo(50,0)
                    ctx.lineTo(50,50)
                    ctx.lineTo(40,50)
                    ctx.arc(0, 50, 40, 0*(Math.PI/180), 270*(Math.PI/180), true)
                    ctx.lineTo(0, 0)
                    ctx.fill()

                    // ctx.fillStyle = 'rgb(38, 8, 189'
                    // ctx.beginPath()
                    // ctx.moveTo(0, 10)
                    // ctx.lineTo(0, 50)
                    // ctx.lineTo(50, 50)
                    // ctx.arc(0, 50, 40, 0*(Math.PI/180), 90*(Math.PI/180), true)
                    // ctx.fill()
                }
            }
        }

        var lastKey
        function snakeConectionFunc(){
            
            snakeConection.display = 'none'
            
            if (lastKey != actualDirection){
                switch (actualDirection){
                    case 'w':
                        setTimeout(
                                    function(){
                                        snakeConection.transform = 'rotate(0deg)'
                                        snakeConection.top = '50px'
                                        snakeConection.left = '5px'
                                        if (hasBody && actualDirection === 'w'){snakeConection.display = 'block'}
                                    }, timeDelay / 1.4
                            )
                        break
                    case 's':
                        setTimeout(
                                    function(){
                                        snakeConection.transform = 'rotate(0deg)'
                                        snakeConection.top = '-10px'
                                        snakeConection.left = '5px'
                                        if (hasBody && actualDirection === 's'){snakeConection.display = 'block'}
                                    }, timeDelay / 1.4
                            )
                        break
                    case 'a':
                        setTimeout(
                                    function(){ 
                                        snakeConection.transform = 'rotate(90deg)'
                                        snakeConection.top = '20px'
                                        snakeConection.left = '35px'
                                        if (hasBody && actualDirection === 'a'){snakeConection.display = 'block'}
                                    }, timeDelay / 1.4
                            )
                        break
                    case 'd':
                        setTimeout(
                                    function(){     
                                        snakeConection.transform = 'rotate(90deg)'
                                        snakeConection.top = '20px'
                                        snakeConection.left = '-25px'
                                        if (hasBody && actualDirection === 'd'){snakeConection.display = 'block'}
                                    }, timeDelay / 1.4
                            )
                        break
                }
                lastKey = actualDirection
            }
        }
    </script>

    <style>
        body, html{
            z-index: 10;
        }
        .nav{
            width: 1400px;
            height: 150px;
            background-color: lightgray;
            z-index: 11;
        }
        #map{
            width: 1400px;
            height: 600px;
            background-color: gray;
            position: relative;
        }
        #snake{
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: green;
            z-index: 10;
        }
        #snake-conection{
            width: 40px;
            height: 10px;
            background-color: rgb(38, 8, 189);
            position: absolute;
            display: none; 
        }
        .snake-body{
            width: 50px;
            height: 50px;
            position: absolute;
        }
        .snake-body-style{
            width: 50px;
            height: 50px;
            background-color: rgb(38, 8, 189);
            position: absolute;
        }
        .food{
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }
        .way{
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }
        .fillet{
            position: absolute;
            z-index: 5;
        }
    </style>
</head>
<body>

    
    <main class="d-flex justify-content-center flex-wrap">
        <div class="nav d-block">

    

            <h1 id="h1-nav"></h1>
            <h2 id="h2-nav"></h2>
        </div>
        <div id="map">
    
            <div id="snake">
                <span id="snake-conection"></span>
            </div>
            
            <div class="food" id="food"></div>

        </div>
    </main>

    <script>
        var pressed = document.getElementById('pressed')

        var snakePos = document.getElementById('snake').style
        var snakeConection = document.getElementById('snake-conection').style

        var foodPos = document.getElementById('food').style

        var snakePosGet = window.getComputedStyle(document.getElementById('snake'))
        var foodPosGet = window.getComputedStyle(document.getElementById('food'))
        initiate()
        randomPosition() //Alterar posição da comida inicial
    </script>
</body>
</html>