<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>

    <!-- fontawesome -->
    <script src="https://kit.fontawesome.com/490ac8585b.js" crossorigin="anonymous"></script>


    <script>
        var stepToCSS = 'px'
        var stepToCalc = 50
        var leftPos = 0
        var topPos = 0
        var timeDelay = 200
        
        var isMoving
        var lastInput

        var actualDirection = null

        var ms = timeDelay/10
        var temp = null
        var timeInputs
        var timeBetweenInputs = 0
        var firstKey = false
        var counter = 0
        var numberKeysDown = 0

        var lastPosTop = 0
        var lastPosLeft = 0


        var isExecutingW = false
        var isExecutingS = false
        var isExecutingA = false
        var isExecutingD = false
        var isExecutingContinuos = false

        var arrayKeys = new Array()
        var arrayBody = new Array()

        document.onkeydown = function(asd){
            if ((asd.key == 'a' || asd.key == 'w' || asd.key == 's' || asd.key == 'd') && (counter > timeBetweenInputs || firstKey === false)){

                //notExecuting()
                moveSnake(asd.key)
                firstKey = true

                counter = 0
                if (numberKeysDown % 2 === 0){ //Contador para evitar dupla inserção de teclas
                    if (timeInputs === undefined){
                        timeInputs = setInterval(
                            function(){
                                counter++
                                document.getElementById('h1-nav').innerHTML = counter
                            },1
                        )
                    }
                }

                numberKeysDown++
            }
            else if (asd.key == 'p'){
                if (isMoving != undefined){
                    clearInterval(isMoving)
                    isMoving = undefined
                }
                else{
                    moveSnake(asd.key)
                }
            }
            else{
                //randomPosition()
            }

        }

        var posString = ''
        var operationString = ''
        var isLeft = false
        var isValid = false

        function notExecuting(){
            isExecutingW = false
            isExecutingS = false
            isExecutingA = false
            isExecutingD = false
        }
        function isExecuting(){
            if (isExecutingW === true || isExecutingS === true || isExecutingA === true || isExecutingD === true || isExecutingContinuos === true){
                return true
            }
            else{
                return false
            }
        }


        var lastPosBodyLeft
        var lastPosBodyTop

        var arrayLastPositions = new Array() //Continuos

        function canMove(firstTarget, secondTarget, operation){

            // arrayLastPositions.push({left: leftPos, top: topPos})

            // if (arrayLastPositions.length === 5){ //Continuos

            //     lastPosLeft = arrayLastPositions[0].left
            //     lastPosTop = arrayLastPositions[0].top

            //     arrayLastPositions.shift()

            // }

            
            lastPosLeft = leftPos
            lastPosTop = topPos
            // if (actualDirection === 'a'){
            //     lastPosLeft = leftPos + 40
            // }
            // else if (actualDirection === 'd'){
            //     lastPosLeft = leftPos - 40
            // }
            // else if (actualDirection === 'w'){
            //     lastPosTop = topPos + 40
            // }
            // else if (actualDirection === 's'){
            //     //lastPosTop = topPos - 40
            //     lastPosLeft = leftPos - 40
            // }
      



            if (bodySet.length === 0){
                lastPosBodyLeft = lastPosLeft
                lastPosBodyTop = lastPosTop
            }

            if ( operation == '+'){
                if(firstTarget == 'leftPos'){
                    leftPos += stepToCalc
                }
                else{
                    topPos += stepToCalc
                }
            }
            else{
                if(firstTarget == 'leftPos'){
                    leftPos -= stepToCalc
                }
                else{
                    topPos -= stepToCalc
                }
            }

            colissionBody()

            if (leaveMap()){
                clearAllInterval()
            }
            else if (isCollidingBody === false && isExecutingContinuos === false){

                snakePos = document.getElementById('snake').style

                if(secondTarget === true){
                    continuosMovement('left')
                    //snakePos.left = leftPos + stepToCSS
                }
                else{
                    continuosMovement('top')
                    //snakePos.top = topPos + stepToCSS
                }

                bodySnakeApply()
            }
        }

        function continuosLeft(){
            if (actualDirection === 'd'){
                snakePos.left = leftPos - (step) + a*b + stepToCSS
            }
            else{
                snakePos.left = leftPos + (step) - a*b + stepToCSS
            }
            b++
            //console.log(a)
            if (a*b === stepToCalc){
                clearInterval(intervalContinuos)
                intervalContinuos = undefined
                snakePos.left = leftPos + stepToCSS
                isExecutingContinuos = false
                b = 1
            }
        }
        function continuosTop(){
            if (actualDirection === 's'){
                snakePos.top = topPos - (step) + a*b + stepToCSS
            }
            else{
                snakePos.top = topPos + (step) - a*b + stepToCSS
            }
            b++
            if (a*b >= stepToCalc){
                clearInterval(intervalContinuos)
                intervalContinuos = undefined
                snakePos.top = topPos + stepToCSS
                isExecutingContinuos = false
                b = 1
            }
        }

        var stepForContinuos = 10
        var intervalContinuos 
        
        var a = stepToCalc / stepForContinuos
        var b = 1
        var step = stepToCalc

        function continuosMovement(directionLocal){

            //console.log(c)

            isExecutingContinuos = true
            if (directionLocal === 'left'){
                intervalContinuos = setInterval(
                    function(){
                        continuosLeft()
                    },timeDelay / stepForContinuos
                )
            }
            else{
                intervalContinuos = setInterval(
                    function(){
                        continuosTop()
                    },timeDelay / stepForContinuos
                )
            }
        }


        function defaultMove(){

            if (arrayKeys.length != 0){
                whichDirection(arrayKeys[0])
                arrayKeys.shift()
            }

            notExecuting()

            //clearInterval(intervalContinuos)

            canMove(posString, isLeft, operationString)
            

            if (leaveMap() === false){
                collisionFood()
                if (hasBody === true && isCollidingBody === false){}
            }

            //document.getElementById('map').innerHTML += '<span class="way" style="left:' + lastPosLeft + stepToCSS +'; top: ' + lastPosTop + stepToCSS +'"></span>'
            //redeclareConst()
        }

        function moveSnake(directionLocal){

            whichDirection(directionLocal)


            //defaultMove()
            if (isMoving === undefined){
                if (isValid === true){

                    defaultMove()

                    isMoving = setInterval(
                        function(){
                            defaultMove()
                        },
                        timeDelay
                    )
                }
            }
        }

        function whichDirection(direction){
            //console.log('DIRECTION: ' + direction)
            //console.log('arrayKEYS: ' + arrayKeys)
            switch (direction){

                case 'w':
                    if (actualDirection != 's' && isExecuting() === false){
                        isExecutingW = true
                        posString = 'topPos'
                        operationString = '-'
                        isLeft = false
                        actualDirection = 'w'
                        //console.log('W')
                        isValid = true
                    }
                    else{
                        isValid = false
                        console.log('W')
                        arrayKeys.push(direction)
                    }
                    break

                case 's':
                    if (actualDirection != 'w' && isExecuting() === false){
                        isExecutingS = true
                        posString = 'topPos'
                        operationString = '+'
                        isLeft = false
                        actualDirection = 's'
                        //console.log('S')
                        isValid = true
                    }
                    else{
                        isValid = false
                        console.log('S')
                        arrayKeys.push(direction)
                    }
                    break

                case 'a':
                    if (actualDirection != 'd' && isExecuting() === false){
                        isExecutingA = true
                        posString = 'leftPos'
                        operationString = '-'
                        isLeft = true
                        actualDirection = 'a'
                        //console.log('A')
                        isValid = true
                    }
                    else{
                        isValid = false
                        console.log('A')
                        arrayKeys.push(direction)
                    }
                    break
                
                case 'd':
                    if (actualDirection != 'a' && isExecuting() === false){
                        isExecutingD = true
                        posString = 'leftPos'
                        operationString = '+'
                        isLeft = true
                        actualDirection = 'd'
                        //console.log('D')
                        isValid = true
                    }
                    else{
                        isValid = false
                        console.log('D')
                        arrayKeys.push(direction)
                    }
                    break              
            }
        }
        function clearAllInterval(){
            clearInterval(isMoving)
            clearInterval(temp)
            clearInterval(timeInputs)
        }
        function leaveMap(){
            if (leftPos < 0 || leftPos >= 1400 || topPos < 0 || topPos >= 600){ 
                console.log('LEAVE MAP')
                return true
            } 
            else{
                return false
            }
        }

        var isCollidingBody = false

        function colissionBody(){

            if (hasBody === true){

                bodySnakeComputed()

                for (let i = 0; i < bodySet.length; i++){

                    let xy = bodyArray

                    if (xy[i].left === leftPos + stepToCSS && xy[i].top === topPos + stepToCSS){

                        isCollidingBody = true
                        clearInterval(isMoving)
                        break
                        isMoving = undefined
                    }
                }
            }
        }

        function collisionFood(){

            if (snakePosGet.top === foodPosGet.top && snakePosGet.left === foodPosGet.left){

                randomPosition()

                hasBody = true

                document.getElementById('map').innerHTML += '<span class="snake-body d-flex justify-content-center align-items-center" style="left:' + lastPosBodyLeft + stepToCSS +'; top: ' + lastPosBodyTop + stepToCSS +'"><span class="snake-body-style"></span></span>'

                // let xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[bodySetStyle.length - 1])
                // console.log(xy.left)
                // bodySetStyle[bodySetStyle.length - 1].style.width = '40px'
                // bodySetStyle[bodySetStyle.length - 1].style.height = '40px' WORKING HERE


                redeclareConst()
            }  

        }
        function redeclareConst(){
            snakePos = document.getElementById('snake').style
            foodPos = document.getElementById('food').style
            snakePosGet = window.getComputedStyle(document.getElementById('snake'))
            foodPosGet = window.getComputedStyle(document.getElementById('food'))
            drawFillet()
        }

        function initiate(){

            var allPosX = []
            var allPosY = []

            var mapStyle = window.getComputedStyle(document.getElementById('map'))

            for (let x = 0; x <= mapStyle.width.replace('px', ''); x += stepToCalc){
                allPosX.push(x)
            }
            for (let y = 0; y <= mapStyle.height.replace('px', ''); y += stepToCalc){
                allPosY.push(y)
            }
        }
        var kls = 0
        function randomPosition(){

            var x = Math.floor(Math.random() * (14*2)) * 50
            var y = Math.floor(Math.random() * (6*2)) * 50

            if (kls === 0){
                x = 100
                y = 50
                kls = 1
            }
            else if( kls === 1){
                x = 400
                y = 50
                kls = 2
            }
            foodPos.left = x + stepToCSS
            foodPos.top = y + stepToCSS

            //foodPos.display = 'none'
            //console.log('X: ' + x + '///' + 'Y: ' + y)
        }

        var bodyArray = new Array()
        const bodySet = document.getElementsByClassName('snake-body')
        const bodySetStyle = document.getElementsByClassName('snake-body-style')

        var hasBody = false

        function bodySnakeComputed(){

            let x = {p1: 0, p2: 0}
            let y = {p1: 0, p2: 0}
            let xy

            for (let i = 0; i < bodySet.length; i++){

                xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[i])
                multStep[i] = 1
                if (i % 2 === 0){

                    x.p1 = xy.left
                    x.p2 = xy.top

                    if (i === 0) {
                        bodyArray[i] = {left: (lastPosLeft) + stepToCSS, top: (lastPosTop) + stepToCSS}
                        //bodySet[i].style.left = (lastPosLeft) + stepToCSS
                        //bodySet[i].style.top = (lastPosTop) + stepToCSS
                    }
                    else{
                        bodyArray[i] = {left: y.p1, top: y.p2}

                        //bodySet[i].style.left = y.p1
                        //bodySet[i].style.top = y.p2
                    }

                    if(i == bodySet.length - 1){

                        lastPosBodyLeft = x.p1.replace('px', '')
                        lastPosBodyTop = x.p2.replace('px', '')
                    }
                }
                else{
                    y.p1 = xy.left
                    y.p2 = xy.top


                    bodyArray[i] = {left: x.p1, top: x.p2}

                    if(i == bodySet.length - 1){
                        lastPosBodyLeft = y.p1.replace('px', '')
                        lastPosBodyTop = y.p2.replace('px', '')
                    }

                    //bodySet[i].style.left = x.p1
                    //bodySet[i].style.top = x.p2
                }
            }
        }
        function continuosBody(){

        }

        var savePosTop
        var savePosLeft
        function bodySnakeApply(){

            if ((savePosLeft === undefined || savePosTop === undefined) && bodyArray.length != 0){
                savePosLeft = lastPosBodyLeft
                savePosTop = lastPosBodyTop
            }

            let xy
            let top
            let left


            if (isCollidingBody === false){

                for (let i = 0; i < bodySet.length; i++){

                    xy = window.getComputedStyle(document.getElementsByClassName('snake-body')[i])
                    top = xy.top
                    left = xy.left
                    if (bodyArray[i].left != xy.left && bodyArray[i].top == xy.top){
                        bodySetStyle[i].style.width = '60px'
                        bodySetStyle[i].style.height = '40px'
                        continuosBody('left', i, left)
                        //console.log('LEFT')
                    }
                    else{
                        //bodySet[i].style.width = '50px'
                    }
                    if(bodyArray[i].top != xy.top && bodyArray[i].left == xy.left){
                        bodySetStyle[i].style.width = '40px'
                        bodySetStyle[i].style.height = '60px'
                        continuosBody('top', i, top)
                        //console.log('TOP')
                    }
                    else{
                        //bodySet[i].style.height = '50px'
                    }

                }
            }
        }

        var multStep = new Array()

        function continuosBodyTop(i, top){
            
            if (Number(bodyArray[i].top.replace('px', '')) > Number(top.replace('px', ''))){
                bodySet[i].style.top = (Number(bodyArray[i].top.replace('px', '')) - (step) + a*multStep[i]) + stepToCSS
            }
            else{
                bodySet[i].style.top = (Number(bodyArray[i].top.replace('px', '')) + (step) - a*multStep[i]) + stepToCSS
            }
            multStep[i]++
            if (a*multStep[i] >= stepToCalc){
                clearInterval(window ["intervalContinuosBody" + i])
                bodySet[i].style.top = bodyArray[i].top
                multStep[i] = 1
            }
        }
        function continuosBodyLeft(i, left){

            if (Number(bodyArray[i].left.replace('px', '')) > Number(left.replace('px', ''))){
                bodySet[i].style.left = (Number(bodyArray[i].left.replace('px', '')) - (step) + a*multStep[i]) + stepToCSS
            }
            else{
                bodySet[i].style.left = (Number(bodyArray[i].left.replace('px', '')) + (step) - a*multStep[i]) + stepToCSS
            }
            multStep[i]++
            if (a*multStep[i] >= stepToCalc){
                clearInterval(window ["intervalContinuosBody" + i])
                bodySet[i].style.left = bodyArray[i].left
                multStep[i] = 1
            }
        }
        var isExecutingContinuosBody = false
        var intervalContinuosBody
        function continuosBody(directionLocal, i, xy){

            isExecutingContinuosBody = true
            
            if (directionLocal === 'left'){
                window ["intervalContinuosBody" + i] = setInterval(
                    function(){
                        continuosBodyLeft(i, xy)
                    },timeDelay / stepForContinuos
                )
            }
            else{
                window ["intervalContinuosBody" + i] = setInterval(
                    function(){
                        continuosBodyTop(i, xy)
                    },timeDelay / stepForContinuos
                )
            }
        }
        
        function drawFillet(){

            var fillet = document.getElementById('fillet')
            var ctx = fillet.getContext('2d')

            if (fillet.getContext){
                
                //ctx.fillRect(0, 0, 100, 100)
                ctx.fillStyle = 'gray'
                ctx.beginPath()
                ctx.lineTo(0, 0)
                ctx.lineTo(50, 0)
                ctx.arc( 0, 50, 50, 0*(Math.PI/180), 270*(Math.PI/180), true)
                ctx.fill()

                ctx.fillStyle = 'rgb(38, 8, 189)'
                ctx.beginPath()
                ctx.lineTo(0, 50)
                ctx.lineTo(50, 50)
                ctx.arc( 0, 50, 50, 0*(Math.PI/180), 270*(Math.PI/180), true)
                ctx.fill()
            }
        }
    </script>

    <style>
        .nav{
            width: 1400px;
            height: 150px;
            background-color: lightgray;
        }
        #map{
            width: 1400px;
            height: 600px;
            background-color: gray;
            position: relative;
        }
        #snake{
            width: 50px;
            height: 50px;
            background-color: green;
            position: relative;
            z-index: 10;
        }
        .snake-body{
            width: 50px;
            height: 50px;
            position: absolute;
        }
        .snake-body-style{
            width: 50px;
            height: 50px;
            background-color: rgb(38, 8, 189);
            position: absolute;
        }
        .food{
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }
        .way{
            width: 50px;
            height: 50px;
            position: absolute;
            background-color: red;
        }
        #fillet{
            position: absolute;
            z-index: 15;
        }
    </style>
</head>
<body onload="drawFillet()">

    
    <main class="d-flex justify-content-center flex-wrap">
        <div class="nav d-block">

            

            <h1 id="h1-nav"></h1>
            <h2 id="h2-nav"></h2>
        </div>
        <div id="map">

            <canvas id="fillet" style="left: 500px; top: 300px;"></canvas>

            <div id="snake"></div>
            
            <div class="food" id="food"></div>
        </div>
    </main>

    <script>
        var pressed = document.getElementById('pressed')
        var snakePos = document.getElementById('snake').style
        var foodPos = document.getElementById('food').style
        var snakePosGet = window.getComputedStyle(document.getElementById('snake'))
        var foodPosGet = window.getComputedStyle(document.getElementById('food'))
        initiate()
        randomPosition() //Alterar posição da comida inicial
    </script>
</body>
</html>